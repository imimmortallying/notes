<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

// CMD..........
// pwd - абсолютный путь к текущему рабочему каталогу
// cd . - текущий каталог
// cd -  - предыдущий каталог
// cd .. - на каталог выше
// cd Git - зайти в папку гит из текущего каталога

// ls - файлы внутри тек. каталога
// ls -R - все файлы в подкаталогах -a - скрытые файлы -al - с подробной информацией

// cat index.html - откроет в терминале файл (не сработало, без ошибки)
// cat> new.txt - создаст файл
// cp Git/new.txt new2.txt - копирует 
// mv - перемещает или переименует
// rm - удалит файл
// mkdir test - создает папку
// rmdir test - удаляет пустую папку
// rm test - удалит папку и содержимое

// GIT ...........
// git init - инициализирует директорию, она становится репозиторием
// git status - можешь проверить, сработала ли команда выше. Узнать текущий статус репозитория

// базовая работа: 1) файл создан "untracked" 2) git add "staged" (подготовленный) 3) git commit "commited" (зафиксированный) || git commit -m "что изменилось"
// либо            1)* файл изменен "modified" 2) 3) аналогично
// т.е. каждый раз при создании файла или его изменении файл получает статус 1) или 1)*, поэтому нужно выполнять 2) и 3)

// git add in different ways:

// git add index.html file2.txt
// git add . - add all files in a current folder
// git add *.html - add all .html extension files in a current folder
// git add someDirectory/*.txt - add all .txt extension files in someDirectory folder
// git add someDir/ - add all files in someDir folder
// git add "*.js" - add all .js extension files in the project

// git log - show history of all commits

// git diff - show the difference between ... current 'untracked' stage and the last commit
// git diff --staged - current 'staged' stage and the last commit
// git diff COMMIT_ID - current repository and chosen commit by id (hash)

// RESET
// git reset - returns to the desired commit
// HEAD-> points at current project stage i.e. current commit?
// HEAD ^ - 1 commit back
// HEAD ^^^ - 3 commits back
// HEAD~2 - 2 commits back

// 3 reset modes: --soft, --mixed, --hard depending on their hardness
// git reset syntax: git reset[--soft | --mixed | --hard] [commit (id, hash or diferent variants with HEAD)]

// git reset --hard - returns a project to chosen commit while completely and irretrievably deletes all commits after the chosen
// ex: git reset --hard HEAD^^

// git reset --mixed - returns a project to a chosen commit while turns all the commit's changes after the chosen into the 'unstaged' stage
// that is, commits are deleted, but changes in a project don't apply till stage ('unstaged') changes to 'staged' (git add) and then to 'commited' (git commit)
// ex: git reset --mixed HEAD~3

// git reset --soft - similarly to the --mixed mode but changes turns into 'staged' stage

// git reset - by default git reset (without mode) uses --mixed mode and HEAD

// by carefull using --git reset hard, because it affects following commits (ex: commit made by your partners) which will result in a few versions of a project
// so don't use it when working in public repository with other programmers

// CHECKOUT
// git checkout - allows to move between commits and see how it looked. This command doesn't delete commits and changes HEAD to 'detached' stage
// which means it separated from current version of a project. All changes made is this stage are deleted when HEAD moved to another commit
// to save thouse changes it's necessary to work with branches correctly 

// git checkout also allows to return files to a selected commit version: git chechout <commit id, hash, HEAD> -- pathToFile1 pathToFile2
// if <identifier> not specified than files return to a last commit version. Works only for 'modified' or 'untracked' changes: git checkot -- index.html
// or even just git checkout -- . - to return all files to a last commit. Works to modified or untracked changes
// so in combination with git reset (which equal to git reset --mixed HEAD)  it's possible to delete 'staged' changes

// COMMIT
// git commit -a -m 'message' is equal to using 2 commands in a row: git add and git commit allowing to skip typing 2 commands
// but it doesn't apply to new 'untracked' files, only to modified
// git commit --amend -m 'new message' - update last commit without creating new one
// if new message -m wasn't added be ready to type ':wq' to leave opening console

// CLEAN
// git clean deletes new files i.e. 'untracked' which couldn't be deleted by using git reset
// git clean -n shows files that will be deleted. git clean -f deletes

// REMOTE
// git remote is a command for viewing remote repositories
// git remote -v - view a list of remote repositories
// git remote add REPOSITORE_NAME REPOSITORY_ADRESS - to add new repository. Ex:
// git remote add origin https://github.com/imimmortallying/notes.git
// REPOSITORY_NAME -->push || <--pull REPOSITORY_ADRESS
// git remote remove REPOSITORY_NAME - to remove repository

// pull algorithm:
// create a new folder -> git inint -> git remote add origin https://github.com/imimmortallying/notes.git -> git pull origin master

/////








    </script>
</body>
</html>