<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

// CMD..........
// pwd - абсолютный путь к текущему рабочему каталогу
// cd . - текущий каталог
// cd -  - предыдущий каталог
// cd .. - на каталог выше
// cd Git - зайти в папку гит из текущего каталога

// ls - файлы внутри тек. каталога
// ls -R - все файлы в подкаталогах -a - скрытые файлы -al - с подробной информацией

// cat index.html - откроет в терминале файл (не сработало, без ошибки)
// cat> new.txt - создаст файл
// cp Git/new.txt new2.txt - копирует 
// mv - перемещает или переименует
// rm - удалит файл
// mkdir test - создает папку
// rmdir test - удаляет пустую папку
// rm test - удалит папку и содержимое

// GIT ...........
// git init - инициализирует директорию, она становится репозиторием
// git status - можешь проверить, сработала ли команда выше. Узнать текущий статус репозитория

// базовая работа: 1) файл создан "untracked" 2) git add "staged" (подготовленный) 3) git commit "commited" (зафиксированный) || git commit -m "что изменилось"
// либо            1)* файл изменен "modified" 2) 3) аналогично
// т.е. каждый раз при создании файла или его изменении файл получает статус 1) или 1)*, поэтому нужно выполнять 2) и 3)

// git add in different ways:

// git add index.html file2.txt
// git add . - add all files in a current folder
// git add *.html - add all .html extension files in a current folder
// git add someDirectory/*.txt - add all .txt extension files in someDirectory folder
// git add someDir/ - add all files in someDir folder
// git add "*.js" - add all .js extension files in the project

// git log - show history of all commits

// git diff - show the difference between ... current 'untracked' stage and the last commit
// git diff --staged - current 'staged' stage and the last commit
// git diff COMMIT_ID - current repository and chosen commit by id (hash)


// git reset - returns to the desired commit

// HEAD-> points at current project stage i.e. current commit?
// HEAD ^ - 1 commit back
// HEAD ^^^ - 3 commits back
// HEAD~2 - 2 commits back

// 3 reset modes: --soft, --mixed, --hard depending on their hardness
// git reset syntax: git reset[--soft | --mixed | --hard] [commit (id, hash or diferent variants with HEAD)]

// git reset --hard - returns a project to chosen commit while completely and irretrievably deletes all commits after the chosen
// ex: git reset --hard HEAD^^

// git reset --mixed - returns a project to a chosen commit while turns all the commit's changes after the chosen into the 'unstaged' stage
// that is, commits are deleted, but changes in a project don't apply till stage ('unstaged') changes to 'staged' (git add) and then to 'commited' (git commit)
// ex: git reset --mixed HEAD~3

// git rese --soft - similarly to the --mixed mode but changes turns into 'staged' stage

// git reset - by default git reset (without mode) uses --mixed mode and HEAD

// by carefull using --git reset hard, because it affects following commits (ex: commit made by your partners) which will result in a few versions of a project
// so don't use it when working in public repository with other programmers

// git checkout - allows to move between commits and see how it looked. This command doesn't delete commits and changes HEAD to 'detached' stage
// which means it separated from current version of a project. All changes made is this stage are deleted when HEAD moved to another commit
// to save thouse changes it's necessary to work with branches correctly 

    </script>
</body>
</html>